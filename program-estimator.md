---

copyright:
  years: 2021, 2022
lastupdated: "2022-09-13"

keywords: quantum, Qiskit, runtime, near time compute

subcollection: quantum-computing

---

{{site.data.keyword.attribute-definition-list}}


# Estimator primitive
{: #program-estimator}


Understand the input and output for the Estimator primitive.
{: shortdesc}

## Overview
{: #estimator-overview}

The Estimator primitive returns an observable expectation value that is generated by given circuits that are run on the target backend. For a full, end-to-end example of how to use this primitive, see [Get started with Estimator](/docs/quantum-computing?topic=quantum-computing-example-estimator).

The maximum execution time is 18000 seconds (5 hours).

## Parameters
{: #estimator-parameters}

- **Input parameters**:
    - **run_options**:
        - **Type**: object
        - **Description**: A collection of key-value pairs identifying the execution options, such as shots.
        - **Required**: False
    - **circuit_indices**:
        - **Type**: array
        - **Description**: Indexes of the circuits to evaluate.
        - **Required**: True
    - **parameter_values**
        - **Type**: array
        - **Description**: Concrete parameters to be bound.
        - **Required**: False
    - **skip_transpilation**:
        - **Description**: Skip circuit transpilation. The default value is False.
        - **Required**: False. 
    - **circuits**:
        - **Description**: A QuantumCircuit or list of QuantumCircuits. The circuits can be parameterized.
        - **Required**: True
    - **parameters**
        - **Type**: array
        - **Description**: Parameters of the quantum circuits.
        - **Required**: False  
    - **observables:**
        - **Type**: ['object', 'array']
        - **Description**: The Hamiltonians to be evaluated.
        - **Required**: False
    - **observable_indices**:
        - **Type**: array
        - **Description**: A list of observable indices. It must have the same length as circuit_indices and parameter_values.
        - **Required**: True   
    - **options**        
        - **Description**: Extra parameters, such as the backend to use.
        - **Required**: False   
- **Returns**:
   - **metadata**:
        - **Type**: array
        - **Description**: Additional metadata. 
        - **Required**: False
   - **value**:
       - **Description**: Estimated expectation values. This is a numpy array. The i{sup}th{/sup} element is calculated by using the circuit and observable that is indexed by the i{sup}th{/sup} circuit_indices and i{sup}th{/sup} observable_indices, and bound with i{sup}th{/sup} parameter_values.
       - **Type**: array
       - **Required**: False

## Example
{: #estimator-example-code}

```Python
from qiskit_ibm_runtime import QiskitRuntimeService, Session, Estimator, Options
from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp

service = QiskitRuntimeService()
options = Options(backend="ibmq_qasm_simulator", optimization_level=1)

with Session(service) as session:
    estimator = Estimator(session=session, options=options)
with Session(service) as session:
    estimator = Estimator(session=session, options=options)

    theta1 = [0, 1, 1, 2, 3, 5]
    theta2 = [0, 1, 1, 2, 3, 5, 8, 13]
    theta3 = [1, 2, 3, 4, 5, 6]

    # calculate [ <psi1(theta1)|H1|psi1(theta1)> ]
    psi1_H1 = estimator.run(circuits=[psi1], observables=[H1], parameter_values=[theta1])
    print(psi1_H1.result())

    # calculate [ <psi1(theta1)|H2|psi1(theta1)>, <psi1(theta1)|H3|psi1(theta1)> ]
    psi1_H23 = estimator.run(circuits=[psi1, psi1], observables=[H2, H3], parameter_values=[theta1]*2)
    print(psi1_H23.result())

    # calculate [ <psi2(theta2)|H2|psi2(theta2)> ]
    psi2_H2 = estimator.run(circuits=[psi2], observables=[H2], parameter_values=[theta2])
    print(psi2_H2.result())

    # calculate [ <psi1(theta1)|H1|psi1(theta1)>, <psi1(theta3)|H1|psi1(theta3)> ]
    psi1_H1_job = estimator.run(circuits=[psi1, psi1], observables=[H1, H1], parameter_values=[theta1, theta3])
    print(psi1_H1_job.result())

    # calculate [ <psi1(theta1)|H1|psi1(theta1)>,
    #             <psi2(theta2)|H2|psi2(theta2)>,
    #             <psi1(theta3)|H3|psi1(theta3)> ]
    psi12_H23 = estimator.run(circuits=[psi1, psi2, psi1], observables=[H1, H2, H3], parameter_values=[theta1, theta2, theta3])
    print(psi12_H23.result())

```
{: codeblock}

The results align with the parameter - circuit - observable tuples previously specified. For example, the first result: `EstimatorResult(values=array([1.53710938]), metadata=[{'variance': 9.249675750732422, 'shots': 1024}])` is the output of the parameter `theta1` and observable `H1` being sent to the first circuit.

Output:
```text
EstimatorResult(values=array([1.59570312]), metadata=[{'variance': 8.661632537841797, 'shots': 1024}])
EstimatorResult(values=array([-0.5390625 ,  0.07421875]), metadata=[{'variance': 0.70941162109375, 'shots': 1024}, {'variance': 1.9894332885742188, 'shots': 1024}])
EstimatorResult(values=array([0.17773438]), metadata=[{'variance': 0.9684104919433594, 'shots': 1024}])
```

## Next steps
{: #next-steps}

- Use the [Getting started guide](/docs/quantum-computing?topic=quantum-computing-quickstart) to create an instance and run your first job.
- Review [Get started with the Sampler primitive](/docs/quantum-computing?topic=quantum-computing-example-estimator) for a step-by-step example of using this primitive.
- Use Qiskit [tutorials](https://qiskit.org/documentation/tutorials.html){: external} to learn how to create circuits with Qiskit.
