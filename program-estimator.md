---

copyright:
  years: 2021, 2022
lastupdated: "2022-03-07"

keywords: quantum, Qiskit, runtime, near time compute

subcollection: quantum-computing

content-type: tutorial
completion-time: 10m

---

{{site.data.keyword.attribute-definition-list}}


# Estimator primitive
{: #program-estimator}
{: toc-content-type="reference"}
{: toc-completion-time="10m"}

Understand the input and output for the Estimator primitive.
{: shortdesc}

## Overview
{: #estimator-overview}

The Estimator primitive returns an observable expectation value generated by given circuits executed on the target backend.  For a full, end-to-end example of how to use this primitive, see [Get started with Estimator](/docs/quantum-computing?topic=quantum-computing-example-estimator).

## Parameters
{: #estimator-parameters}

- **Input parameters**:
   - **circuits**:
      - **Description**: A QuantumCircuit or list of QuantumCircuits. The circuits can be parameterized.
      - **Required**: True
   - **observables**: Properties of the system or function being evaluated.  Currently must be opflow `PauliSumOp` (primitive is SparsePauliOp) or quantum_info operator, `BaseOperator`, which is compatible with SparsePauliOp.
   - **parameters**:
      - **Description**: Optional input for parameterized circuits.
      - **Required**: False
   - **run-options**:
      - **Description**: Various run options, such as the number of **shots** (how many times to run each circuit).
      - **Required**: False
   - **transpile_options**:
      - **Description**: A collection of kwargs passed to transpile.  Available options are:
         - initial_layout: Optional[Union[Layout, Dict, List]] = None
         - layout_method: Optional[str] = None
         - routing_method: Optional[str] = None
         - translation_method: Optional[str] = None
         - approximation_degree: Optional[float] = None
         - seed_transpiler: Optional[int] = None
         - optimization_level: Optional[int] = None
      - **Required**: False.   
   - **Example**

      ```Python
      observable = PauliSumOp.from_list(
         [
             ("II", -1.052373245772859),
             ("IZ", 0.39793742484318045),
             ("ZI", -0.39793742484318045),
             ("ZZ", -0.01128010425623538),
             ("XX", 0.18093119978423156),
         ]
      )
      ansatz = RealAmplitudes(num_qubits=2, reps=2)
      parameters = [0, 1, 1, 2, 3, 5]
      run_options = {"shots": 1000}

      program_inputs = {
             "circuits": ansatz,
             "observables": observable,
             "parameters": parameters,
             "run_options": run_options
      }
      ```
      {: codeblock}

- **options**:
   - **Description**: Various options, such as the name of the **backend** to run the program on.
   - **Required**: False.  If no backend is specified, the program will be run on the next available backend that you have access to.
   - **Example**:

      ```Python
      options = {"backend_name": "ibmq_qasm_simulator"}
      ```
      {: codeblock}

## Output values
{: #estimator-parameters-read}

- **values**:  
   - **Description**: Quasiprobabilities for each circuit.
   - **Type**: list
- **variances**:  
   - **Description**: Variances for each circuit.
   - **Type**: list
- **shots**:  
   - **Description**: The number of shots that were run.
   - **Type**: integer
- **Example**:

   ```python
   EstimatorArrayResult(values=array([-1.27506899, -0.59895964]), variances=array([0.30091147, 0.22917904]))
   shots: 1000
   ```
